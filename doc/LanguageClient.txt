*LanguageClient.txt* Language Server Protocol support for vim and neovim *LanguageClient*


==============================================================================
CONTENTS                                               *LanguageClientContents*

1. Usage ....................... |LanguageClientUsage|
2. Configuration ............... |LanguageClientConfiguration|
3. Commands .................... |LanguageClientCommands|
4. Functions ................... |LanguageClientFunctions|
5. Mappings .................... |LanguageClientMappings|
6. Events ...................... |LanguageClientEvents|
7. License ..................... |LanguageClientLicense|
8. Bugs ........................ |LanguageClientBugs|
9. Contributing ................ |LanguageClientContributing|

==============================================================================
1. Usage                                                 *LanguageClientUsage*

Before using LanguageClient, it is necessary to specify commands that are
going to be used to start a language server. See |LanguageClient_serverCommands|
for detail. Here is a simple example config: >

    let g:LanguageClient_serverCommands = {
        \ 'rust': ['rustup', 'run', 'stable', 'rls'],
        \ }

After that, open a file with one of the above filetypes, functionalities
provided by language servers should be available out of the box.

At this point, call any provided function as you like. See
|LanguageClientFunctions| for a complete list of functions. Usually one would
like to map these functions to shortcuts, for example: >

    nnoremap <silent> K :call LanguageClient#textDocument_hover()<CR>
    nnoremap <silent> gd :call LanguageClient#textDocument_definition()<CR>
    nnoremap <silent> <F2> :call LanguageClient#textDocument_rename()<CR>

You can also use slightly cleaner Plug mappings instead of the full function name: >

    nmap <silent> K <Plug>(lcn-hover)
    nmap <silent> gd <Plug>(lcn-definition)
    nmap <silent> <F2> <Plug>(lcn-rename)

You can apply these mappings only for buffers with supported filetypes with a
simple function: >

    function LC_maps()
      if has_key(g:LanguageClient_serverCommands, &filetype)
        nmap <buffer> <silent> K <Plug>(lcn-hover)
        nmap <buffer> <silent> gd <Plug>(lcn-definition)
        nmap <buffer> <silent> <F2> <Plug>(lcn-rename)
      endif
    endfunction

    autocmd FileType * call LC_maps()

If one is using deoplete/nvim-completion-manager at the same time, completion
should work out of the box. Otherwise, completion is available with 'C-X C-O'
('omnifunc').

Alternatively, set 'completefunc': >
    set completefunc=LanguageClient#complete
<
If the language server supports, diagnostic/lint information will be displayed
via gutter and syntax highlighting with real time editing. At the same time,
that info is populated into the quickfix list (or location list), which can be
accessed by regular quickfix/location list operations.

To use the language server with Vim's formatting operator |gq|, set 'formatexpr': >
    set formatexpr=LanguageClient#textDocument_rangeFormatting_sync()
<
==============================================================================
2. Configuration                                 *LanguageClientConfiguration*

2.1 g:LanguageClient_serverCommands          *g:LanguageClient_serverCommands*

Dictionary to specify the servers to be used for each filetype. The keys are
strings representing the filetypes and the values are either
  1 - a list of strings that form a command
  2 - a dictionary with keys name, command and initializationOptions, where:
    - name: is the name of the server, which should match the root node of the
      configuration options specified in the settings.json file for this server
    - command: is the same list of strings in option 1
    - initializationOptions: is an optional dictionary with options to be passed
      to the server. The values to be set here are highly dependent on each
      server so you should see the documentation for each server to find out
      what to configure in here (if anything).  The options set in
      initializationOptions are merged with the default settings for each
      language server and with the workspace settings defined by the user in
      the files specified in the variable `LanguageClient_settingsPath'. The
      order in which these settings are merged is first the defualt settings,
      then the server settings configured in this section and lastly the
      contents of the files in the `LanguageClient_settingsPath` variable in
      the order in which they were listed.

For example: >

    let g:LanguageClient_serverCommands = {
        \ 'rust': ['rustup', 'run', 'stable', 'rls'],
        \ 'go': {
        \   'name': 'gopls',
        \   'command': ['gopls'],
        \   'initializationOptions': {
        \     'usePlaceholders': v:true,
        \     'codelens': {
        \       'generate': v:true,
        \       'test': v:true,
        \     },
        \   },
        \ },
        \}

In the configuration for the rust filetype above, 'run', 'stable', and 'rls'
are arguments to the 'rustup' command line tool. And in the configuration for
the go filetype the server is configured to run the command `gopls` with no
additional arguments, and with the initialization options set in the
`initializationOptions` key.

You can also use a tcp connection to the server, for example: >
    let g:LanguageClient_serverCommands = {
        \ 'javascript': ['tcp://127.0.0.1:2089'],
        \ }

Note: environmental variables are not supported except home directory alias `~`.

Default: {}



Valid Option: Map<String, List<String> | {
    name: String
    command: List<String>
    initializationOptions?: Map<String, Any>
  }>

2.2 g:LanguageClient_diagnosticsDisplay  *g:LanguageClient_diagnosticsDisplay*

Control how diagnostics messages are displayed.

Default: >
    {
        1: {
            "name": "Error",
            "texthl": "LanguageClientError",
            "signText": "✖",
            "signTexthl": "LanguageClientErrorSign",
            "virtualTexthl": "Error",
        },
        2: {
            "name": "Warning",
            "texthl": "LanguageClientWarning",
            "signText": "⚠",
            "signTexthl": "LanguageClientWarningSign",
            "virtualTexthl": "Todo",
        },
        3: {
            "name": "Information",
            "texthl": "LanguageClientInfo",
            "signText": "ℹ",
            "signTexthl": "LanguageClientInfoSign",
            "virtualTexthl": "Todo",
        },
        4: {
            "name": "Hint",
            "texthl": "LanguageClientInfo",
            "signText": "➤",
            "signTexthl": "LanguageClientInfoSign",
            "virtualTexthl": "Todo",
        },
    }

2.3 g:LanguageClient_diagnosticsSignsMax  *g:LanguageClient_diagnosticsSignsMax*

Control how many diagnostics signs are displayed.

Default: v:null (Show all signs)
Valid options: v:null | number

2.4 g:LanguageClient_changeThrottle      *g:LanguageClient_changeThrottle*

Interval in seconds during which textDocument_didChange is suppressed. For
example: >

    let g:LanguageClient_changeThrottle = 0.5

This will make LanguageClient pause 0.5 second to send text changes to
server after one textDocument_didChange is sent.

Default: v:null (No throttling)
Valid options: v:null | number

2.5 g:LanguageClient_autoStart                  *g:LanguageClient_autoStart*

Whether to start language servers automatically when opening a file of
associated filetype.

Default: 1.

2.6 g:LanguageClient_autoStop                   *g:LanguageClient_autoStop*

Whether to stop language servers automatically when closing vim.
associated filetype.

Default: 1.

2.7 g:LanguageClient_selectionUI                *g:LanguageClient_selectionUI*

Selection UI used when there are multiple entries.

Default: If fzf is loaded, use "fzf", otherwise use "location-list".
Valid options: "fzf" | "quickfix" | "location-list" | |Funcref|

If you use a |Funcref|, the referenced function should have two arguments
(source, sink). The "source" argument can be either a command string or a
list. The sink argument can be a command string or a |Funcref| that takes the
selected line as its first argument.

An example implementation is "s:FZF()" in autoload/LanguageClient.vim. For
details, see the source and sink arguments of fzf#run():
https://github.com/junegunn/fzf/blob/master/README-VIM.md#fzfrun

Another example, this time using vim-clap: >

	function! MySelectionUI(source, sink) abort
		return clap#run({'id': 'LCN', 'source': a:source, 'sink': a:sink})
	endfunction

	let g:LanguageClient_selectionUI = function('MySelectionUI')

2.7 g:LanguageClient_selectionUI_autoOpen                *LanguageClient_selectionUI_autoOpen*
Selection UI auto open when selectionUI is not "fzf"

Default: 1
Valid options: 1 | 0

2.8 g:LanguageClient_trace                           *g:LanguageClient_trace*

Trace setting passed to server.

Default: "off"
Valid options: "off" | "messages" | "verbose"

2.9 g:LanguageClient_diagnosticsList        *g:LanguageClient_diagnosticsList*

List used to fill diagnostic messages.

Default: "Quickfix"
Valid options: "Quickfix" | "Location" | "Disabled"

2.10 g:LanguageClient_diagnosticsEnable    *g:LanguageClient_diagnosticsEnable*

Whether to handle diagnostic messages, including gutter, highlight and
quickfix/location list.

Default: 1
Valid options: 1 | 0

2.11 g:LanguageClient_windowLogMessageLevel  *g:LanguageClient_windowLogMessageLevel*

Maximum MessageType to show messages from window/logMessage notifications.

Default: "Warning"
Valid options: "Error" | "Warning" | "Info" | "Log"

2.12 g:LanguageClient_settingsPath              *g:LanguageClient_settingsPath*

Path for language server settings, or list of such paths. If not an absolute
path this is relative to the workspace directory. If several paths are
provided, then the corresponding settings are merged with precedence going to
the last file.

The initialization options found in the files in this config are combined with
the initialization options specified in the server command, if any. The former
taking precedence over the latter.

Note that the key under which the initialization options for each server lives
matches the key under which the server expects it's configuration. This is
important for servers that can request configuration via a
`workspace/configuration` request.

Previously, the initialization options lived under a `initializationOptions`
key, which worked, but made answering that `workspace/configuration` request
hard, since we couldn't really get the correct path to the setting the server
requested. Since version 0.1.161 of this plugin, that key has been deprecated
and you'll see a message saying that you should move off of it if your settings
file includes an `initializationOptions` key.

Example settings file content: >
    {
        "gopls": {
          "usePlaceholders": true,
          "local": "github.com/my/pkg",
        },
        "rust-analyzer": {
          "inlayHints": {
            "enable": true,
            "chainingHints": true
          },
        },
    }

Default: ".vim/settings.json"

2.13 g:LanguageClient_loadSettings             *g:LanguageClient_loadSettings*

Whether to load language server settings.

Default: 1
Valid options: 1 | 0

2.14 g:LanguageClient_loggingFile               *g:LanguageClient_loggingFile*

Log file location.

Default: null
Valid options: any valid path. Please note that `~` is not a valid path and you
need to `expand` it.

Example:

    `let g:LanguageClient_loggingFile = expand('~/.vim/LanguageClient.log')`


2.15 g:LanguageClient_loggingLevel           *g:LanguageClient_loggingLevel*

Logging level.

Default: 'WARN'
Valid options: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR'

2.16 g:LanguageClient_serverStderr             *g:LanguageClient_serverStderr*

Path for language server stderr.

Default: None
Valid options: any valid path.

2.17 g:LanguageClient_rootMarkers              *g:LanguageClient_rootMarkers*

Customized project root markers. Generally a heuristic algorithm within this
plugin should be able to detect project root automatically. This option is
provided in case the algorithm failed.

Example setting 1. List of string array. Shell-like glob is supported. >
    let g:LanguageClient_rootMarkers = ['.root', 'project.*']

Example setting 2. Map filetype to string array. >
    let g:LanguageClient_rootMarkers = {
        \ 'javascript': ['project.json'],
        \ 'rust': ['Cargo.toml'],
        \ }

Default: v:null
Valid option: Array<String> | Map<String, Array<String>>

2.18 g:LanguageClient_fzfOptions                *g:LanguageClient_fzfOptions*

Customize fzf. Check fzf documentation for available options.

Default: v:null
Valid option: Array<String> | String

2.19 g:LanguageClient_hasSnippetSupport   *g:LanguageClient_hasSnippetSupport*

Override detection of snippet support.

If this is not set, the language client will determine whether snippets are
supported by looking for installed plugins that are known to support them.

Set to 1 (or 0) to enable (or disable) snippet support, skipping the automatic
detection.

Valid options: 1 | 0

2.20 g:LanguageClient_waitOutputTimeout   *g:LanguageClient_waitOutputTimeout*

Duration of time (in seconds) to wait for language server to return output
before timing out.

Default: 10
Valid options: number

2.21 g:LanguageClient_hoverPreview             *g:LanguageClient_hoverPreview*

Controls how hover output is displayed. Must be one of the following:
    Never  - Never use preview window, always echo hover output
    Auto   - Use preview window for hover entries longer than one line (default)
    Always - Always use preview window, never echo hover output

Default: "Auto"
Valid options: "Never", "Auto", "Always"

2.22 g:LanguageClient_selectionUIContextMenu *g:LanguageClient_selectionUIContextMenu* *g:LanguageClient_fzfContextMenu*

Should the selection UI be used for `LanguageClient_contextMenu()`.

(Alias for the deprecated `LanguageClient_fzfContextMenu`)

Default: 1
Valid options: 1 | 0

2.23 g:LanguageClient_completionPreferTextEdit
*g:LanguageClient_completionPreferTextEdit*

(Experimental) Should prefer use textEdit it is present in
CompletionItem.

Note: textEdit support requires vim >= v8.0.1493, or vim >= v8.1.0039, or
neovim >= 0.3.0.

Default: 0
Valid options: 1 | 0

2.24 g:LanguageClient_documentHighlightDisplay *g:LanguageClient_documentHighlightDisplay*

Control how document highlights are displayed.

Default: >
    {
        1: {
            "name": "Text",
            "texthl": "SpellCap",
        },
        2: {
            "name": "Read",
            "texthl": "SpellLocal",
        },
        3: {
            "name": "Write",
            "texthl": "SpellRare",
        },
    }

2.25 g:LanguageClient_useVirtualText          *g:LanguageClient_useVirtualText*

Specify whether to use virtual text to display diagnostics.

Default: "All" whenever virtual text is supported.
Valid Options: "All" | "No" | "CodeLens" | "Diagnostics"

2.26 g:LanguageClient_useFloatingHover *g:LanguageClient_useFloatingHover*

When the value is set to 1, |LanguageClient#textDocument_hover()| opens
documentation in a floating window instead of preview.
This variable is effective only when the floating window feature is
supported. Check by running >
    :echomsg exists('*nvim_open_win')

Default: 1 when a floating window is supported, otherwise 0
Valid Options: 1 | 0

2.27 g:LanguageClient_floatingHoverHighlight *g:LanguageClient_floatingHoverHighlight*

Control how floating window hover highlights are displayed.

Default: Normal:CursorLine

2.28 g:LanguageClient_usePopupHover           *g:LanguageClient_usePopupHover*

When the value is set to 1, |LanguageClient#textDocument_hover()| opens
documentation in a popup window instead of preview.
This variable is effective only when the popup window feature is
supported, which is supported only in vim 8.2+. Check by running >
    :echomsg has('popupwin')

Default: 1 when a popup window is supported, otherwise 0
Valid Options: 1 | 0

2.29 g:LanguageClient_virtualTextPrefix     *g:LanguageClient_virtualTextPrefix*

When the value is set to a valid string and |g:LanguageClient_useVirtualText| is
enabled, all virtual text lines are prefixed with the defined string.
This variable is effective only when the virtual text feature is
supported.

Default: Empty string ('')
Valid Options: string

2.30 g:LanguageClient_diagnosticsMaxSeverity  *g:LanguageClient_diagnosticsMaxSeverity*

Maximum severity to show diagnostic messages.

Default: "Hint"
Valid options: "Error" | "Warning" | "Information" | "Hint"

2.31 g:LanguageClient_diagnosticsIgnoreSources  *g:LanguageClient_diagnosticsIgnoreSources*

Does not show the diagnostics message which has the source specified by this
options.

Default: "[]"

2.32 g:LanguageClient_echoProjectRoot  *g:LanguageClient_echoProjectRoot*

Whether to echo messages in vim of the form: "Project root: /home/user/myproject" when
the root of a project is detected using g:LanguageClient_rootMarkers.

Default: 1 to display the messages
Valid options: 1 | 0

2.33 g:LanguageClient_semanticHighlightMaps   *g:LanguageClient_semanticHighlightMaps*

String to list/map map. Defines the mapping of semantic highlighting "scopes" to
highlight groups. This depends on the LSP server supporting the proposed
semantic highlighting protocol, see:

https://github.com/microsoft/language-server-protocol/issues/18
https://github.com/microsoft/vscode-languageserver-node/issues/368


Like |g:LanguageClient_serverCommands| this is a map where the keys are
filetypes. However each submap has |regexp| keys and highlight group names
as values (see |highlight-groups|).
>
    let g:LanguageClient_semanticHighlightMaps = {
        \ 'java': {
        \   '^entity.name.function.java': 'Function',
        \   '^entity.name.type.class.java': 'Type',
        \   '^[^:]*entity.name.function.java': 'Function',
        \   '^[^:]entity.name.type.class.java': 'Type'
        \ }
        \ }

The |regexp| in the keys will be used to match semantic scopes. Then any symbols
that have a semantic scope that matches the key will be highlighted with the
associated highlight group value. Currently there is no defined order if a
semantic scope can match multiple keys, so it is recommended to make the keys
more specific to only match the desired scope(s).

There are a fixed set of semantic scopes defined by the LSP server on startup.
These can be viewed by calling |LanguageClient_showSemanticScopes| which will
show all the semantic scopes and their currently mapped highlight group for
the currently open buffer's filetype.
>
     call LanguageClient_showSemanticScopes()

     == Output from eclipse.jdt.ls ==

     Highlight Group:
      None
     Semantic Scope:
      invalid.deprecated.java
       meta.class.java
        source.java

     Highlight Group:
      None
     Semantic Scope:
      variable.other.autoboxing.java
       meta.method.body.java
        meta.method.java
         meta.class.body.java
          meta.class.java
           source.java

     ...

Each semantic scope is a list of strings. They are printed with increasing
indent to make it easier to read. For example the first scope is:
>
     ['invalid.deprecated.java', 'meta.class.java', 'source.java']

It is currently isn't mapped to any highlight group as indicated by the None.

Often its more useful to find what semantic scope corresponds to a piece of
text. This can be done by calling |LanguageClient_showCursorSemanticHighlightSymbols|
while hovering over the text of interest.
>
     call LanguageClient_showCursorSemanticHighlightSymbols()

When matching the semantic scopes to keys in |LanguageClient_semanticHighlightMaps|,
the scopes are concatentated using |LanguageClient_semanticScopeSeparator|
which is set to the string |':'| by default. For the previous example the
semantic scope would have this string form using the default separator:
>
     invalid.deprecated.java:meta.class.java:source.java

Here are a couple of example |regexp| keys that can/cannot match this scope:
>
     'meta.class.java' =~ 'invalid.deprecated.java:meta.class.java:source.java'
     '^meta.class.java' !~ 'invalid.deprecated.java:meta.class.java:source.java'
     '^invalid.deprecated.java' =~ 'invalid.deprecated.java:meta.class.java:source.java'
     'source.java$' =~ 'invalid.deprecated.java:meta.class.java:source.java'
     'meta.class.java:source.java' =~ 'invalid.deprecated.java:meta.class.java:source.java'
     'invalid.deprecated.java:.*:source.java' =~ 'invalid.deprecated.java:meta.class.java:source.java'

Example configuration for eclipse.jdt.ls:
>
     let g:LanguageClient_semanticHighlightMaps = {}
     let g:LanguageClient_semanticHighlightMaps['java'] = {
       \ '^storage.modifier.static.java:entity.name.function.java': 'JavaStaticMemberFunction',
       \ '^meta.definition.variable.java:meta.class.body.java:meta.class.java': 'JavaMemberVariable',
       \ '^entity.name.function.java': 'Function',
       \ '^[^:]*entity.name.function.java': 'Function',
       \ '^[^:]*entity.name.type.class.java': 'Type',
       \ }

     highlight! JavaStaticMemberFunction ctermfg=Green cterm=none guifg=Green gui=none
     highlight! JavaMemberVariable ctermfg=White cterm=italic guifg=White gui=italic


2.34 g:LanguageClient_applyCompletionAdditionalTextEdits *g:LanguageClient_applyCompletionAdditionalTextEdits*

Indicates whether completionItem additional text edits should be applied.

Default: 1
Valid options: 1 | 0

2.35 g:LanguageClient_preferredMarkupKind *g:LanguageClient_preferredMarkupKind*

Sets the preferred markup kind. This value is sent to the server and is
normally used to decide whether to send plaintext or markdown in things like
hover or completion items docunmentation.

This should be set to an array of values with the preferred markup kinds in
order of preferrence. Leaving this config unset, will send `null` to the
server, effectively letting it decide which markup kind to use.

Example setting 1. Set the preferred markup kind to `plaintext`
  ```
  let g:LanguageClient_preferredMarkupKind = ['plaintext']
  ```

Example setting 2. Set the preferred markup kind to `plaintext` and `markdown`
as a fallback.

  ```
  let g:LanguageClient_preferredMarkupKind = ['plaintext', 'markdown']
  ```

Example setting 3. Set the preferred markup kind to `markdown`

  ```
  let g:LanguageClient_preferredMarkupKind = ['markdown']
  ```

This setting may have no effect if the server decides not to honour it.

Default: v:null
Valid options: Array<String>

2.36 g:LanguageClient_floatingWindowStyle  *g:LanguageClient_floatingWindowStyle*

Style of opened Neovim floating window.

Default: 'minimal'
Valid options: 'minimal'

2.37 g:LanguageClient_hideVirtualTextsOnInsert *g:LanguageClient_hideVirtualTextsOnInsert*

Hides all virtual texts for the current buffer while editing in insert mode.

Default: 0
Valid options: 1 | 0

2.38 g:LanguageClient_setOmnifunc                *g:LanguageClient_setOmnifunc*

Whether set buffer omnifunc to 'LanguageClient#complete'.

Default: v:true
Valid options: v:true | v:false

2.39 g:LanguageClient_binaryPath                  *g:LanguageClient_binaryPath*

Full path to languageclient binary.

Default: 'bin/languageclient' relative to plugin root.
Valid options: String

2.40 g:LanguageClient_enableExtensions          *g:LanguageClient_enableExtensions*

LanguageClient-neovim provides extensions for some language servers, such as gopls or rust-analyzer.
These extensions can be turned on or off, and they are configurable per language (not per language
server).

An example of the extensions provided is running Rust or Go tests in a vim terminal. This takes
advantage of the commands provided by rust-analyzer or gopls (respectively) and executes those
commands in a vim terminal.

Example config:
  ```
  let g:LanguageClient_enableExtensions = {
    \ 'go': v:false,
    \ 'rust': v:true,
    \ }
  ```
In this example we explicitly disable extensions for the filetype `go`, and enable them for `rust`.
Filetypes not included in this config will also have their extensions disabled, unless you
explicitly enable them like we did for `rust`.

The default value for this config, or the absence of this config, enables extensions for all filetypes.

Default: v:null

2.41 g:LanguageClient_codeLensDisplay          *g:LanguageClient_codeLensDisplay*

Control how code lenses are displayed.

Default: >
  {
    "virtualTexthl": "LanguageClientCodeLens",
  }

2.42 g:LanguageClient_hoverMarginSize        *g:LanguageClient_hoverMarginSize*

When using floating windows to open hover previews (for more information see
|g:LanguageClient_useFloatingHover|), this setting controls whether and how
big of a margin to draw around the contents of the hover.

Having some margin looks nice, so the default is 1.

Floating windows don't have a true way to set padding/margin on them, so the
strategy used is to add one line above and below the language server's raw
hover response, and one space character before the start of every non-empty
line in the hover response.

Having a space in front of the hover content can cause some syntax
highlighters to mess up (because e.g., they have a regex expecting a syntax
construct to be anchored to the start of a line). To turn off adding this
margin, set this setting to 0. Example:
>
  let g:LanguageClient_hoverMarginSize = 0
<
Default: 1

2.43 g:LanguageClient_restartOnCrash          *g:LanguageClient_restartOnCrash*

If enabled, the client will attempt to restart the server on the event that it
unexpectedly crashes.

Default: 1

2.44 g:LanguageClient_maxRestartRetries          *g:LanguageClient_maxRestartRetries*

Max number of times to attempt to recover from a server crash. Each language
handles its own count independently.

Default: 5

2.45 g:LanguageClient_showCompletionDocs  *g:LanguageClient_showCompletionDocs*

Show completion item documentation in a floating window right next to pmenu.

Default: 1
Valid options: 1 | 0

==============================================================================
3. Commands                                           *LanguageClientCommands*

3.1 LanguageClientStart                                  *LanguageClientStart*

Start language server for current buffer.

3.2 LanguageClientStop                                    *LanguageClientStop*

Stop current language server.

==============================================================================
4. Functions                                          *LanguageClientFunctions*

*LanguageClient#Call()*
*LanguageClient_Call()*
Signature: LanguageClient#Call(method: String, params: Map | List, callback: Funcref | String | List | Null)

Call a method of current language server. After receiving response, if
callback is a function, it is invoked with response as params, if the callback
is a list, the response is pushed at the end of it, if callback is null, it is
handled by this plugin default handler.

*LanguageClient#Notify()*
*LanguageClient_Notify()*
Signature: LanguageClient#Notify(method: String, params: Map | List)

Send a notification to the current language server.

*LanguageClient_contextMenu()*
Signature: LanguageClient#contextMenu(...)

Show list of all available actions.

If optional dependency FZF is installed, actions will be displayed in a FZF
prompt, selecting one of the action will then call the action's function.

To skip FZF prompt even if FZF is installed and use native numbered list,
add this variable to vimrc:
`let g:LanguageClient_fzfContextMenu = 0`

For Denite users, a source with name 'contextMenu' is provided.

*LanguageClient#textDocument_hover()*
*LanguageClient_textDocument_hover()*
Signature: LanguageClient#textDocument_hover(...)

Show type info (and short doc) of identifier under cursor.

If you're using Neovim 0.4.0 or later, this function opens documentation in a
floating window. The window is automatically closed when you move the cursor.
Or calling this function again just after opening the floating window moves
the cursor into the window. It is useful when documentation is longer and you
need to scroll down or you want to yank some text in the documentation.

*LanguageClient#textDocument_definition()*
*LanguageClient_textDocument_definition()*
Signature: LanguageClient#textDocument_definition(...)

Goto definition under cursor.

*LanguageClient#textDocument_typeDefinition()*
*LanguageClient_textDocument_typeDefinition()*
Signature: LanguageClient#textDocument_typeDefinition(...)

Goto type definition under cursor.

*LanguageClient#textDocument_implementation()*
*LanguageClient_textDocument_implementation()*
Signature: LanguageClient#textDocument_implementation(...)

Goto implementation under cursor.

*LanguageClient#textDocument_rename()*
Signature: LanguageClient#textDocument_rename()
           LanguageClient#textDocument_rename({"newName": ...})

Rename identifier under cursor.

Accepts an optional dictionary argument, which if passed with the {newName}
property, will rename to the provided value without prompting the user. This
can be useful in situations where {newName} can be wholly determined from the
existing name (e.g. capitalization, camelCase, etc).


Example bindings combining with tpope/vim-abolish:
>
    " Rename - rn => rename
    noremap <leader>rn :call LanguageClient#textDocument_rename()<CR>

    " Rename - rc => rename camelCase
    noremap <leader>rc :call LanguageClient#textDocument_rename(
                \ {'newName': Abolish.camelcase(expand('<cword>'))})<CR>

    " Rename - rs => rename snake_case
    noremap <leader>rs :call LanguageClient#textDocument_rename(
                \ {'newName': Abolish.snakecase(expand('<cword>'))})<CR>

    " Rename - ru => rename UPPERCASE
    noremap <leader>ru :call LanguageClient#textDocument_rename(
                \ {'newName': Abolish.uppercase(expand('<cword>'))})<CR>
<

*LanguageClient#textDocument_codeLens()*
*LanguageClient_textDocument_codeLens()*
Signature: LanguageClient#textDocument_codeLens(...)

Computes and displays the codeLens for the currently open file.

*LanguageClient#handleCodeLensAction()*
*LanguageClient_handleCodeLensAction()*
Signature: LanguageClient#handleCodeLensAction(...)

Runs the action associated with the codeLens at the current line. It does
nothing if the codeLens is not actionable.

*LanguageClient#textDocument_documentSymbol()*
*LanguageClient_textDocument_documentSymbol()*
Signature: LanguageClient#textDocument_documentSymbol(...)

List of current buffer's symbols.

If optional dependency FZF is installed, symbols will be displayed in a FZF
prompt, selecting one of the symbol will then goto the symbol's definition.

For Denite users, a source with name 'documentSymbol' is provided.

*LanguageClient#textDocument_references()*
*LanguageClient_textDocument_references()*
Signature: LanguageClient#textDocument_references(...)

List all references of identifier under cursor.

If optional dependency FZF is installed, locations will be displayed in a FZF
prompt, selecting one of the entry will then goto the reference location.

For Denite users, a source with name 'references' is provided.

*LanguageClient#textDocument_visualCodeAction()*
*LanguageClient_textDocument_visualCodeAction()*
Signature: LanguageClient#textDocument_visualCodeAction(...)

Show code actions at current visual selection.

*LanguageClient#textDocument_codeAction()*
*LanguageClient_textDocument_codeAction()*
Signature: LanguageClient#textDocument_codeAction(...)

Show code actions at current location.

*LanguageClient#textDocument_completion()*
*LanguageClient_textDocument_completion()*
Signature: LanguageClient#textDocument_completion(...)

Get a list of completion items at current editing location. Note, this is a
synchronous call.

When using a supported completion manager (deoplete and
nvim-completion-manager are supported), completion should work out of the box.

*LanguageClient#textDocument_formatting()*
*LanguageClient_textDocument_formatting()*
Signature: LanguageClient#textDocument_formatting(...)

Format current document.

*LanguageClient#textDocument_rangeFormatting()*
*LanguageClient_textDocument_rangeFormatting()*
Signature: LanguageClient#textDocument_rangeFormatting(...)

Format selected lines.

*LanguageClient#textDocument_documentHighlight()*
*LanguageClient_textDocument_documentHighlight()*
Signature: LanguageClient#textDocument_documentHighlight(...)

Highlight usages of the symbol under the cursor.

*LanguageClient#clearDocumentHighlight()*
*LanguageClient_clearDocumentHighlight()*
Signature: LanguageClient#clearDocumentHighlight()

Clear the symbol usages highlighting.

*LanguageClient#workspace_symbol()*
*LanguageClient_workspace_symbol()*
Signature: LanguageClient#workspace_symbol([query: String], ...)

List of project's symbols.

If optional dependency FZF is installed, symbols will be displayed in a FZF
prompt, selecting one of the symbol will then goto the symbol's definition.

For Denite users, a source with name 'workspaceSymbol' is provided.

*LanguageClient#workspace_applyEdit()*
*LanguageClient_workspace_applyEdit()*
Signature: LanguageClient#workspace_applyEdit(params: Dict, callback: Function | List | Null)

Apply a workspace edit.

*LanguageClient#workspace_executeCommand()*
*LanguageClient_workspace_executeCommand()*
Signature: LanguageClient#workspace_executeCommand(command: String, [arguments: Any], [callback: Function | List | Null])

Execute a workspace command.

*LanguageClient#setLoggingLevel()*
*LanguageClient_setLoggingLevel()*
Signature: LanguageClient#setLoggingLevel(level: String)

Set the plugin logging level.

Valid logging levels are 'ERROR', 'WARN'(default), 'INFO', 'DEBUG'.

*LanguageClient#setDiagnosticsList()*
Signature: LanguageClient#setDiagnosticsList(diagnosticsList: String)

Set the destination of diagnostics.

Valid options are 'Quickfix', 'Location', 'Disabled'.

*LanguageClient#registerServerCommands()*
*LanguageClient_registerServerCommands()*
Signature: LanguageClient#registerServerCommands(commands: Map)

Register/Override commands to start language servers.

*LanguageClient#registerHandlers*
*LanguageClient_registerHandlers*
Signature: LanguageClient#registerHandlers(handlers: Map)

Register/Override method/notification handlers.

Example >
    function! HandleWindowProgress(params) abort
        echomsg json_encode(a:params)
    endfunction

    call LanguageClient#registerHandlers({
        \ 'window/progress': 'HandleWindowProgress',
        \ })

*LanguageClient#serverStatus()*
*LanguageClient_serverStatus()*
Signature: LanguageClient#serverStatus()

Get language server status. 0 for server idle. 1 for server busy.

*LanguageClient#serverStatusMessage()*
*LanguageClient_serverStatusMessage()*
Signature: LanguageClient#serverStatusMessage()

Get a detail message of server status.

*LanguageClient#isServerRunning()*
*LanguageClient_isServerRunning()*
Signature: LanguageClient#isServerRunning()

Get wheter if language server is running for current buffer. 0 for server not working for current buffer file
type. 1 for working.

*LanguageClient#statusLine()*
*LanguageClient_statusLine()*
Signature: LanguageClient#statusLine()

Example status line making use of |LanguageClient_serverStatusMessage|.

*LanguageClient#statusLineDiagnosticsCounts()*
*LanguageClient_statusLineDiagnosticsCounts()*
Signature: LanguageClient#statusLineDiagnosticsCounts()

Get diagnostics of current buffer in dictionary.

Example >
    function! YourStatusLineMessage() abort
      let l:diagnosticsDict = LanguageClient#statusLineDiagnosticsCounts()
      let l:errors = get(l:diagnosticsDict,'E',0)
      let l:warnings = get(l:diagnosticsDict,'W',0)
      let l:informations = get(l:diagnosticsDict,'I',0)
      let l:hints = get(l:diagnosticsDict,'H',0)
      return l:errors + l:warnings + l:informations + l:hints == 0 ? "✔ " : "E:" . l:errors . " " . "W :" . l:warnings . "I:" . l:informations . " " . "H:" . l:hints
    endfunction

*LanguageClient#cquery_base*
*LanguageClient_cquery_base*
Signature: LanguageClient#cquery_base(...)

Call $cquery/base.

*LanguageClient#cquery_callers*
*LanguageClient_cquery_callers*
Signature: LanguageClient#cquery_callers(...)

Call $cquery/callers.

*LanguageClient#cquery_vars*
*LanguageClient_cquery_vars*
Signature: LanguageClient#cquery_vars(...)

Call $cquery/vars.

*LanguageClient#java_classFileContents*
Signature: LanguageClient#java_classFileContents(...)

Call java/classFileContents.

*LanguageClient_showSemanticScopes*
Signature: LanguageClient_showSemanticScopes(...)

Get all Semantic Scopes and their associated highlight groups for the current
filetype (filetype of the currently open buffer) and print them.

*LanguageClient_showCursorSemanticHighlightSymbols*
Signature: LanguageClient_showCursorSemanticHighlightSymbols(...)

Get the Semantic Scope of the symbol currently under the cursor.
The result gets displayed in a popup.

*LanguageClient#explainErrorAtPoint*
Signature: LanguageClient#explainErrorAtPoint(...)

Show detailed error under cursor.

*LanguageClient#debugInfo*
Signature: LanguageClient#debugInfo(...)

Print out debug info.

*LanguageClient#diagnosticsNext*
Signature: LanguageClient#diagnosticsNext()

Moves the cursor to the next diagnostic in the buffer, relative to the current cursor position.

*LanguageClient#diagnosticsPrevious*
Signature: LanguageClient#diagnosticsPrevious()

Moves the cursor to the previous diagnostic in the buffer, relative to the current cursor position.

*LanguageClient#textDocument_switchSourceHeader*
Signature: LanguageClient#textDocument_switchSourceHeader(...)

Calls clangd's `textDocument/switchSourceHeader` extension request.

*LanguageClient#executeCodeAction*
Signature: LanguageClient#executeCodeAction(kind, ...)

Tries to execute the code action with the give kind under the cursor position.
The action will only be executed if there is exactly one code action with that
kind under the cursor.

This function can be used to create commands for common LSP actions, such as
`source.organizeImports`.  To do so you can create a command like this:

  command! OrganizeImports call LanguageClient#executeCodeAction('source.organizeImports')

Note that this only works for code actions, not commands, and only in normal
mode.

==============================================================================
5. Mappings                                           *LanguageClientMappings*

LanguageClient provides various Plug mappings which can be used to set up
custom mappings. For example, to create a mapping to call the rename function
you would create a custom mapping like this:

  nmap <silent><F2> <Plug>(lcn-rename)

The full list of Plug mappings is:

*(lcn-menu)*
Calls LanguageClient_contextMenu.

*(lcn-hover)*
Calls LanguageClient_textDocument_hover.

*(lcn-rename)*
Calls LanguageClient_textDocument_rename.

*(lcn-definition)*
Calls LanguageClient_textDocument_definition.

*(lcn-type-definition)*
Calls LanguageClient_textDocument_typeDefinition.

*(lcn-references)*
Calls LanguageClient_textDocument_references.

*(lcn-implementation)*
Calls LanguageClient_textDocument_implementation.

*(lcn-code-action)*
Calls LanguageClient_textDocument_codeAction if called in normal model or
LanguageClient_textDocument_visualCodeAction if called in visual mode.

*(lcn-code-lens-action)*
Calls LanguageClient_handleCodeLensAction.

*(lcn-symbols)*
Calls LanguageClient_textDocument_documentSymbol.

*(lcn-highlight)*
Calls LanguageClient_textDocument_documentHighlight.

*(lcn-explain-error)*
Calls LanguageClient_textDocument_explainErrorAtPoint.

*(lcn-format)*
Calls LanguageClient_textDocument_formatting.

*(lcn-format-sync)*
Calls LanguageClient_textDocument_formatting_sync.

*(lcn-diagnostics-next)*
Calls LanguageClient_diagnosticsNext.

*(lcn-diagnostics-prev)*
Calls LanguageClient_diagnosticsPrevious.


==============================================================================
6. Events                                               *LanguageClientEvents*

LanguageClient provides two events for use with |User| |autocmd|s.

6.1 LanguageClientStarted
*LanguageClientStarted*

This event is triggered after LanguageClient has successfully started.

6.2 LanguageClientStopped
*LanguageClientStopped*

This event is triggered after LanguageClient has stopped.

Example: >
  augroup LanguageClient_config
    autocmd!
    autocmd User LanguageClientStarted setlocal signcolumn=yes
    autocmd User LanguageClientStopped setlocal signcolumn=auto
  augroup END

6.3 LanguageClientDiagnosticsChanged
*LanguageClientDiagnosticsChanged*

This event is triggered when diagnostics changed.

6.4 LanguageClientTextDocumentDidOpenPost
*LanguageClientTextDocumentDidOpenPost*

Triggered after textDocument/didOpen notification is sent to language server.

6.5 LanguageServerCrashed
*LanguageServerCrashed*

This event is triggered when a language server unexpectedly quits.

==============================================================================
7. License                                             *LanguageClientLicense*

The MIT License.

==============================================================================
8. Bugs                                                   *LanguageClientBugs*

Please report all bugs at https://github.com/autozimu/LanguageClient-neovim/issues

If you believe you've found a bug in this plugin, please first try to help
narrow down where the error happens, which will reduce bug fix time/effort
significantly.

Experiment with VS Code plugin if the language server has one.

Try increasing logging level to 'INFO' or 'DEBUG' using the
|LanguageClient_setLoggingLevel| function, and check the log file.

There is also a utility script in: >

    $RUNTIME/tests/wrapper-server.sh

which can work like a proxy and logs all stdin and stdout of the language
server into a log file.

==============================================================================
9. Contributing                                   *LanguageClientContributing*

https://github.com/autozimu/LanguageClient-neovim

vim: ft=help
